#!/usr/bin/env python
'''
parse a MAVLink protocol XML file and generate a Go implementation

Copyright Jeyong Shin 2017
Released under GNU GPL version 3 or later

mavlink.go
-> common.go, ardupilot.go, ...

Create mavlink.go.
Search dialect files (for import).
each file translate to .go file.
 * enum
 * message conflict check (same id)


var messages = map[uint8]MavlinkMessage {
    0: Heartbeat
}

func NewMAVLinkMessage(msgid uint8, data []byte) (MAVLinkMessage, error) {
    message := messages[msgid]
    if message != nil {
        message.Decode(data)
        return message, nil
    }
    return nil, fmt.Errorf("Unknown Message ID: %v", msgid)
}

type Heartbeat struct {
    CUSTOM_MODE uint32
    TYPE uint8
    AUTOPILOT uint8
    ....
}

func NewHeartbeat() *Heartbeat {
    M := Heartbeat{}
    m.CUSTOM_MODE = CUSTOM_MODE
    return &m
}

func (*Heartbeat) Id() uint8 {
    return 0
}

func (*Heartbeat) Len() uint8 {
    return 9
}

func (*Heartbeat) Crc() uint8 {
    return 50
}

func (*Heartbeat) Pack() []byte {
    data := new(bytes.Buffer)
    binary.Write(data, binary.LittleEndian, m.CUSTOM_MODE)
    binary.Write(data, binary.LittleEndian, m.TYPE`)
    return data.Bytes()
}

func (*Heartbeat) Unpack(buf []byte) {
    data := bytes.NewBuffer(buf)
    binary.Read(data, binary.LittleEndian, &m.CUSTOM_MODE)
    binary.Read(data, binary.LittleEndian, &m.TYPE)
}

'''

from __future__ import print_function

from builtins import range
import os
import platform
from . import mavtemplate

t = mavtemplate.MAVTemplate()

map = {
        'float'    : 'float32',
        'double'   : 'float64',
        'char'     : 'string',
        'int8_t'   : 'int8',
        'uint8_t'  : 'uint8',
        'uint8_t_mavlink_version'  : 'uint8',
        'int16_t'  : 'int16',
        'uint16_t' : 'uint16',
        'int32_t'  : 'int32',
        'uint32_t' : 'uint32',
        'int64_t'  : 'int64',
        'uint64_t' : 'uint64',
}

def generate_mavlink(directory, filelist, xml_list, msgs):
    print("Generating MAVLink.Go file")

    mavparse.mkdir_p(directory)
    filename = 'MAVLink.go'
    filepath = os.path.join(directory, filename)


    outf = open(filepath, "w")
    generate_header(outf, filelist, xml_list, filename)
    append_static_code('MAVLink.go', outf)
    generate_message_mappings_array(outf, msgs)
    generate_message_lengths_array(outf, msgs)
    generate_message_crc_extra_array(outf, msgs)
    outf.close()

def generate_header(outf, filelist, xml_list, filename):
    """Generate Go file with source files list and creation date"""

    t.write(outf, """
//
//  ${FILENAME}
//  MAVLink Protocol Go Library
//
//  Generated from ${FILELIST} on ${PARSE_TIME} by mavgen_go.py
//  https://github.com/jeyong/MAVLinkGo
//
package mavlink

import (
    "bytes"
    "encoding/binary"
    "fmt"
)

""", {'FILENAME' : filename,
      'FILELIST' : ", ".join(filelist),
      'PARSE_TIME' : xml_list[0].parse_time})


def generate_messages():


map = {
        'float'    : 'float',
        'double'   : 'double',
        'char'     : 'byte',
        'int8_t'   : 'sbyte',
        'uint8_t'  : 'byte',
        'uint8_t_mavlink_version'  : 'B',
        'int16_t'  : 'Int16',
        'uint16_t' : 'UInt16',
        'int32_t'  : 'Int32',
        'uint32_t' : 'UInt32',
        'int64_t'  : 'Int64',
        'uint64_t' : 'UInt64',
        }


def generate_preamble(outf, msgs, args, xml):
    print("Generating preamble")
    t.write(outf, """
/*
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ${FILELIST}

Note: this file has been auto-generated. DO NOT EDIT
*/

using System;
""", {'FILELIST' : ",".join(args)})

def generate_xmlDocSummary(outf, summaryText, tabDepth):
    indent = '\t' * tabDepth
    escapedText = summaryText.replace("\n","\n%s///" % indent)
    outf.write("\n%s/// <summary>\n" % indent)
    outf.write("%s/// %s\n" % (indent, escapedText))
    outf.write("%s/// </summary>\n" % indent)


def generate_enums(outf, enums):
    print("Generating enums")
    outf.write("namespace MavLink\n{\n")
    for e in enums:
            #if len(e.description) > 0:
        generate_xmlDocSummary(outf, e.description, 1)
        outf.write("\tpublic enum %s : uint\n\t{\n" % e.name)

        for entry in e.entry:
            if len(entry.description) > 0:
                generate_xmlDocSummary(outf, entry.description, 2)
            outf.write("\t\t%s = %u,\n" % (entry.name, entry.value))

        outf.write("\n\t}\n\n")
    outf.write("\n}\n")

def generate_classes(outf, msgs):
    print("Generating class definitions")

    outf.write("""


namespace MavLink\n{

    public abstract class MavlinkMessage
    {
        public abstract int Serialize(byte[] bytes, ref int offset);
    }
""")

    for m in msgs:
        if (len(m.description) >0):
            generate_xmlDocSummary(outf, m.description, 1)
        outf.write("""\tpublic class Msg_%s : MavlinkMessage
    {
""" % m.name.lower())

        for f in m.fields:
            if (f.description.upper() != f.name.upper()):
                generate_xmlDocSummary(outf, f.description, 2)
            if (f.array_length):
                outf.write("\t\tpublic %s[] %s; // Array size %s\n" % (map[f.type], mapFieldName.get(f.name, f.name), f.array_length))
            else:
                outf.write("\t\tpublic %s %s;\n" % (map[f.type], mapFieldName.get(f.name, f.name)))

        outf.write("""
        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_%s(this, bytes, ref offset);
            }
""" % m.name.upper())

        outf.write("\t}\n\n")
    outf.write("}\n\n")



def generate_Deserialization(outf, messages):

    # Create the deserialization funcs
    for m in messages:
        classname="Msg_%s" % m.name.lower()
        outf.write("\n\t\tinternal static MavlinkMessage Deserialize_%s(byte[] bytes, int offset)\n\t\t{\n" % (m.name))
        offset = 0

        outf.write("\t\t\treturn new %s\n" % classname)
        outf.write("\t\t\t{\n")

        for f in m.ordered_fields:
            if (f.array_length):
                outf.write("\t\t\t\t%s =  ByteArrayUtil.%s(bytes, offset + %s, %s),\n" % (mapFieldName.get(f.name, f.name), mapType[f.type][0], offset, f.array_length))
                offset += (f.array_length * mapType[f.type][1])
                continue

            # mapping 'char' to byte here since there is no real equivalent in the CLR
            if (f.type == 'uint8_t' or f.type == 'char' ):
                    outf.write("\t\t\t\t%s = bytes[offset + %s],\n" % (mapFieldName.get(f.name, f.name),offset))
                    offset+=1
            else:
                outf.write("\t\t\t\t%s = bitconverter.%s(bytes, offset + %s),\n" % (mapFieldName.get(f.name, f.name), mapType[f.type][0] ,  offset))
                offset += mapType[f.type][1]

        outf.write("\t\t\t};\n")
        outf.write("\t\t}\n")


def generate_Serialization(outf, messages):

    # Create the table of serialization delegates
    for m in messages:
        classname="Msg_%s" % m.name.lower()

        outf.write("\n\t\tinternal static int Serialize_%s(this %s msg, byte[] bytes, ref int offset)\n\t\t{\n" % (m.name, classname))
        offset=0

        # Now (since Mavlink 1.0) we need to deal with ordering of fields
        for f in m.ordered_fields:

            if (f.array_length):
                outf.write("\t\t\tByteArrayUtil.ToByteArray(msg.%s, bytes, offset + %s, %s);\n" % (f.name, offset, f.array_length))
                offset += f.array_length * mapType[f.type][1]
                continue

            if (f.type == 'uint8_t'):
                outf.write("\t\t\tbytes[offset + %s] = msg.%s;\n" % (offset,mapFieldName.get(f.name, f.name)))
                offset+=1
            elif (f.type == 'int8_t'):
                outf.write("\t\t\tbytes[offset + %s] = unchecked((byte)msg.%s);\n" % (offset,mapFieldName.get(f.name, f.name)))
                offset+=1
            elif (f.type == 'char'):
                outf.write("\t\t\tbytes[offset + %s] = msg.%s; // todo: check int8_t and char are compatible\n" % (offset,mapFieldName.get(f.name, f.name)))
                offset+=1
            else:
                outf.write("\t\t\tbitconverter.GetBytes(msg.%s, bytes, offset + %s);\n" % (mapFieldName.get(f.name, f.name),offset))
                offset += mapType[f.type][1]

        outf.write("\t\t\toffset += %s;\n" % offset)
        outf.write("\t\t\treturn %s;\n" % m.id)
        outf.write("\t\t}\n")


def generate_CodecIndex(outf, messages, xml):

    outf.write("""

/*
MAVLink protocol implementation (auto-generated by mavgen.py)

Note: this file has been auto-generated. DO NOT EDIT
*/

using System;
using System.Collections;
using System.Collections.Generic;

namespace MavLink
{
    public static class MavlinkSettings
    {
""")
    outf.write('\t\tpublic const string WireProtocolVersion = "%s";' % xml[0].wire_protocol_version)
    outf.write('\n\t\tpublic const byte ProtocolMarker = 0x%x;' % xml[0].protocol_marker)
    outf.write('\n\t\tpublic const bool CrcExtra = %s;' % str(xml[0].crc_extra).lower())
    outf.write('\n\t\tpublic const bool IsLittleEndian = %s;' % str(xml[0].little_endian).lower())

    outf.write("""
    }

    public delegate MavlinkMessage MavlinkPacketDeserializeFunc(byte[] bytes, int offset);

    //returns the message ID, offset is advanced by the number of bytes used to serialize
    public delegate int MavlinkPacketSerializeFunc(byte[] bytes, ref int offset, object mavlinkPacket);

    public class MavPacketInfo
    {
        public MavlinkPacketDeserializeFunc Deserializer;
        public int [] OrderMap;
        public byte CrcExtra;

         public MavPacketInfo(MavlinkPacketDeserializeFunc deserializer, byte crcExtra)
         {
             this.Deserializer = deserializer;
             this.CrcExtra = crcExtra;
         }
    }

    public static class MavLinkSerializer
    {
        public static void SetDataIsLittleEndian(bool isLittle)
        {
            bitconverter.SetDataIsLittleEndian(isLittle);
        }

        private static readonly FrameworkBitConverter bitconverter = new FrameworkBitConverter();

        public static Dictionary<int, MavPacketInfo> Lookup = new Dictionary<int, MavPacketInfo>
        {""")

    for m in messages:
        classname="Msg_%s" % m.name.lower()
        outf.write("\n\t\t\t{%s, new MavPacketInfo(Deserialize_%s, %s)}," % (m.id, m.name, m.crc_extra))
    outf.write("\n\t\t};\n")
